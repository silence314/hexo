---
title: MySQL的ACID
tags:
  - MySQL
typora-root-url: ../../themes/butterfly/source
date: 2020-10-22 17:17:53
description: 总结一下MySQL的ACID特性，分别是怎么实现的
cover: /blogImg/事务隔离级别.png
categories: MySQL
---

# ACID特性

ACID是衡量事务的四个特性：

- 原子性（Atomicity，或称不可分割性）
- 一致性（Consistency）
- 隔离性（Isolation）
- 持久性（Durability）

按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；InnoDB默认事务隔离级别是可重复读，不满足隔离性；Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性

# 原子性

## 定义

原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。

## 实现原理：undo log

在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。

下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。

以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。

# 持久性

## 定义

持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

## 实现原理：redo log

redo log和undo log都属于InnoDB的事务日志。下面先聊一下redo log存在的背景。

InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。

Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。

于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。

既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：

1. 刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。
2. 刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。

## redo log与binlog

我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：

1. 作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。

2. 层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。

3. 内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。

4. 写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：

- 前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。
- 除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。

# 隔离性

## 定义

**与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。**隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。

隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个方面：

- (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性
- (一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性

## 锁机制

首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。

锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

**行锁与表锁**

按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

### Innodb中乐观锁和悲观锁的实现

#### 乐观锁

乐观锁一般来说有以下2种方式：

1. 使用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的 “version” 字段来实现。当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。
2. 使用时间戳（timestamp）。乐观锁定的第二种实现方式和第一种差不多，同样是在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳（timestamp）, 和上面的version类似，也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。

```mysql
update table set n=n+1, version=version+1 where id=#{id} and version=#{version};
```

#### 悲观锁

```mysql
select…for update
```

- **明确指定主键，并且有此数据，row lock**
- **明确指定主键，若查无此数据，无lock**
- **无主键，table lock**
- **主键不明确，table lock**(用不到索引的几种查询方式，比如<>, like%, >,<)
- **明确指定索引，并且有此数据，row lock**
- **明确指定索引，若查无此数据，无lock**

## 脏读，不可重复读，幻读

### 脏读

当前事务(A)中可以读到其他事务(B)未提交的数据（脏数据），这种现象是脏读。举例如下（以账户余额表为例）：

![脏读](/blogImg/脏读.png)

### 不可重复读

在事务A中先后两次读取同一个数据，两次读取的结果不一样，这种现象称为不可重复读。脏读与不可重复读的区别在于：前者读到的是其他事务未提交的数据，后者读到的是其他事务已提交的数据。举例如下：

![不可重复读](/blogImg/不可重复读.png)

### 幻读

在事务A中按照某个条件先后两次查询数据库，两次查询结果的条数不同，这种现象称为幻读。不可重复读与幻读的区别可以通俗的理解为：前者是数据变了，后者是数据的行数变了。举例如下：

![幻读](/blogImg/幻读.png)

## 事务隔离级别

SQL标准中定义了四种隔离级别，并规定了每种隔离级别下上述几个问题是否存在。一般来说，隔离级别越低，系统开销越低，可支持的并发越高，但隔离性也越差。隔离级别与读问题的关系如下：

![事务隔离级别](/blogImg/事务隔离级别.png)

在实际应用中，**读未提交**在并发时会导致很多问题，而性能相对于其他隔离级别提高却很有限，因此使用较少。**可串行化**强制事务串行，并发效率很低，只有当对数据一致性要求极高且可以接受没有并发时使用，因此使用也较少。因此在大多数数据库系统中，默认的隔离级别是**读已提交**(如Oracle)或可重复读

## MVCC

就是多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

为什么需要MVCC呢？数据库通常使用锁来实现隔离性。最原生的锁，锁住一个资源后会禁止其他任何线程访问同一个资源。但是很多应用的一个特点都是读多写少的场景，很多数据的读取次数远大于修改的次数，而读取数据间互相排斥显得不是很必要。所以就使用了一种读写锁的方法，读锁和读锁之间不互斥，而写锁和写锁、读锁都互斥。这样就很大提升了系统的并发能力。之后人们发现并发读还是不够，又提出了能不能让读写之间也不冲突的方法，就是读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到自己特定版本的数据。当然快照是一种概念模型，不同的数据库可能用不同的方式来实现这种功能。

MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作。其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据行, 而不是符合当前事务版本的数据行。而 SERIALIZABLE 则会对所有读取的行都加锁。

MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。InnoDB实现MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：

1. 隐藏列：InnoDB中每行数据都有隐藏列，隐藏列中包含了本行数据的事务id、指向undo log的指针等。
2. 基于undo log的版本链：前面说到每行数据的隐藏列中包含了指向undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。

**ReadView**

已提交读和可重复读的区别就在于它们生成ReadView的策略不同。

ReadView中主要就是有个列表来存储我们系统中当前活跃着的读写事务，也就是begin了还未提交的事务。通过这个列表来判断记录的某个版本是否对当前事务可见。其中最主要的与可见性相关的属性如下：

**up_limit_id**：当前已经提交的事务号 + 1，事务号 < up_limit_id ，对于当前Read View都是可见的。理解起来就是创建Read View视图的时候，之前已经提交的事务对于该事务肯定是可见的。

**low_limit_id**：当前最大的事务号 + 1，事务号 >= low_limit_id，对于当前Read View都是不可见的。理解起来就是在创建Read View视图之后创建的事务对于该事务肯定是不可见的。

**trx_ids**：为活跃事务id列表，即Read View初始化时当前未提交的事务列表。所以当进行可重复读的时候，trx_ids中的事务对于本事务是不可见的（除了自身事务，自身事务对于表的修改对于自己当然是可见的）。理解起来就是创建Read View时，将当前活跃事务ID记录下来，后续即使他们提交对于本事务也是不可见的。

用一张图更好的理解一下：

![ReadView可见性](/blogImg/ReadView可见性.jpg)

举个栗子

首先有这样一张表

![mvcc栗子1](/blogImg/mvcc栗子1.jpeg)

比如现在有个事务id是60的执行的这条记录的修改语句

![mvcc栗子2](/blogImg/mvcc栗子2.jpeg)

此时在undo日志中就存在版本链

![mvcc栗子3](/blogImg/mvcc栗子3.jpeg)

提交事务id是60的记录后，接着有一个事务id为100的事务，修改name=小明2，但是事务还没提交。则此时的版本链是：

![mvcc栗子4](/blogImg/mvcc栗子4.jpeg)

此时另一个事务发起select语句查询id=1的记录，因为trx_ids当前只有事务id为100的，所以该条记录不可见，继续查询下一条，发现trx_id=60的事务号小于up_limit_id，则可见，直接返回结果小明1。

那这时候我们把事务id为100的事务提交了，并且新建了一个事务id为110也修改id为1的记录name=小明3，并且不提交事务。这时候版本链就是：

![mvcc栗子6](/blogImg/mvcc栗子6.jpeg)

这时候之前那个select事务又执行了一次查询,要查询id为1的记录。

如果你是已提交读隔离级别READ_COMMITED，这时候你会重新一个ReadView，那你的活动事务列表中的值就变了，变成了[110]。按照上的说法，你去版本链通过trx_id对比查找到合适的结果就是强哥2。

如果你是可重复读隔离级别REPEATABLE_READ，这时候你的ReadView还是第一次select时候生成的ReadView,也就是列表的值还是[100]。所以select的结果是强哥1。所以第二次select结果和第一次一样，所以叫可重复读！

也就是说已提交读隔离级别下的事务在每次查询的开始都会生成一个独立的ReadView,而可重复读隔离级别则在第一次读的时候生成一个ReadView，之后的读都复用之前的ReadView。

这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView生成策略的不同实现不同的隔离级别。

## **next-key 锁**

next-key 锁包含两部分：

- 记录锁（行锁）
- 间隙锁

加锁规则有以下特性，我们会在后面的案例中逐一解释：

1. 加锁的基本单位是（next-key lock）,他是左开右闭原则
2. 插叙过程中访问的对象会增加锁
3. 索引上的等值查询--给唯一索引加锁的时候，next-key lock升级为行锁
4. 索引上的等值查询--向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁
5. 唯一索引上的范围查询会访问到不满足条件的第一个值为止

案例数据

| id(主键) | c（普通索引） | d（无索引） |
| -------- | ------------- | ----------- |
| 5        | 5             | 5           |
| 10       | 10            | 10          |
| 15       | 15            | 15          |
| 20       | 20            | 20          |
| 25       | 25            | 25          |

以上数据为了解决幻读问题，更新的时候不只是对上述的五条数据增加行锁，还对于中间的取值范围增加了6间隙锁，（-∞，5]（5，10]（10，15]（15，20]（20，25]（25，+supernum] （其中supernum是数据库维护的最大的值。为了保证间隙锁都是左开右闭原则。）

### 案例一：间隙锁简单案例

| 步骤 | 事务A                                             | 事务B                                                        |
| ---- | ------------------------------------------------- | ------------------------------------------------------------ |
| 1    | begin; select * from t where id = 11  for update; | -                                                            |
| 2    | -                                                 | insert into user value(12,12,12) ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) |
| 3    | commit;                                           | -                                                            |

当有如下事务A和事务B时，事务A会对数据库表增加（10，15]这个区间锁，这时insert id = 12 的数据的时候就会因为区间锁（10，15]而被锁住无法执行。

### 案例二： 间隙锁死锁问题

| 步骤 | 事务A                                                        | 事务B                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | begin; select * from t where id = 9  for update;             | -                                                            |
| 2    | -                                                            | begin; select * from t where id = 6  for update;             |
| 3    | -                                                            | insert into user value(7,7,7) ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) |
| 4    | insert into user value(7,7,7) ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) | -                                                            |

不同于写锁相互之间是互斥的原则，间隙锁之间不是互斥的，如果一个事务A获取到了（5,10]之间的间隙锁，另一个事务B也可以获取到（5,10]之间的间隙锁。这时就可能会发生死锁问题，如下案例。
 事务A获取到（5,10]之间的间隙锁不允许其他的DDL操作，在事务提交，间隙锁释放之前，事务B也获取到了间隙锁（5,10]，这时两个事务就处于死锁状态

### 案例三： 等值查询—唯一索引

| 步骤 | 事务A                                     | 事务B                                                        | 事务C                             |
| ---- | ----------------------------------------- | ------------------------------------------------------------ | --------------------------------- |
| 1    | begin; update u set d= d+ 1 where id = 7; | -                                                            | -                                 |
| 2    | -                                         | insert into u (8,8,8); ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) | -                                 |
| 4    | -                                         | -                                                            | update set d = d+ 1 where id = 10 |

1.加锁的范围是（5,10]的范围锁
 2.由于数据是等值查询，并且表中最后数据id = 10 不满足id= 7的查询要求，故id=10 的行级锁退化为间隙锁，（5,10）
 3.所以事务B中id=8会被锁住，而id=10的时候不会被锁住

### 案例四： 等值查询—普通索引

| 步骤 | 事务A                                                   | 事务B                               | 事务C                                                        |
| ---- | ------------------------------------------------------- | ----------------------------------- | ------------------------------------------------------------ |
| 1    | begin; select id form t where c = 5 lock in share mode; | -                                   | -                                                            |
| 2    | -                                                       | update t set d = d + 1 where id = 5 | -                                                            |
| 4    | -                                                       | -                                   | insert into values (7,7,7)![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) |

1.加锁的范围是（0,5]，（5,10]的范围锁
 2.由于c是普通索引，根据原则4，搜索到5后继续向后遍历直到搜索到10才放弃，故加锁范围为（5,10]
 3.由于查询是等值查询，并且最后一个值不满足查询要求，故间隙锁退化为（5,10）
 4.因为加锁是对普通索引c加锁，而且因为索引覆盖，没有对主键进行加锁，所以事务B执行正常
 5.因为加锁范围（5,10）故事务C执行阻塞
 6.需要注意的是，lock in share mode 因为覆盖索引故没有锁主键索引，如果使用for update 程序会觉得之后会执行更新操作故会将主键索引一同锁住

### 案例五： 范围查询—唯一索引

| 步骤 | 事务A                                                        | 事务B                                                        | 事务C                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | begin; select *  form t where id >= 10 and id <11  for update | -                                                            | -                                                            |
| 2    | -                                                            | insert into values(8,8,8)   insert into values(13,13,13) ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) | -                                                            |
| 4    | -                                                            | -                                                            | update t set d = d+ 1 where id = 15 ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) |

1. next-key lock 增加范围锁（5,10]
2. 根据原则5，唯一索引的范围查询会到第一个不符合的值位置，故增加（10，15]
	 3.因为等值查询有id =10 根据原则3间隙锁升级为行锁，故剩余锁[10,15]
	 4.因为查询并不是等值查询，故[10,15]不会退化成[10,15)
	 5.故事务B（13,13,13）阻塞，事务C阻塞

### 案例六： 范围查询—普通索引

| 步骤 | 事务A                                                      | 事务B                                                        | 事务C                                                        |
| ---- | ---------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | begin; select *  form t where c >= 10 and c <11 for update | -                                                            | -                                                            |
| 2    | -                                                          | insert into values(8,8,8)   ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) | -                                                            |
| 4    | -                                                          | -                                                            | update t set d = d+ 1 where c = 15 ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) |

1. next-key lock 增加范围锁（5,10]，（10，15]
	 2.因为c是非唯一索引，故（5,10]不会退化为10
	 3.因为查询并不是等值查询，故[10,15]不会退化成[10,15)
	 4.所以事务B和事务C全部堵塞

### 案例八： 普通索引-等值问题

上面的数据增加一行（30,10,30），这样在数据库中存在的c=10的就有两条记录

| 步骤 | 事务A                             | 事务B                                                        | 事务C                                                        |
| ---- | --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | begin; delete from t where c = 10 | -                                                            | -                                                            |
| 2    | -                                 | insert into values(12,12,12)   ![\color{red}{blocked}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bblocked%7D) | -                                                            |
| 4    | -                                 | -                                                            | update t set d = d+ 1 where c = 15 ![\color{red}{ok}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bok%7D) |

1. next-key lock 增加范围锁（5,10]，（10，15]
	 2.因为是等值查询故退化为（5,10]，（10，15），故事务B阻塞，事务C执行成功
	 加锁的范围如下图

![普通索引等值问题](/blogImg/普通索引等值问题.jpg)

### 案例九： 普通索引-等值Limit问题

| 步骤 | 事务A                                      | 事务B                                                        | 事务C                                                        |
| ---- | ------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | begin; delete from t where c = 10  limit 2 | -                                                            | -                                                            |
| 2    | -                                          | insert into values(12,12,12)   ![\color{red}{OK}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7BOK%7D) | -                                                            |
| 4    | -                                          | -                                                            | update t set d = d+ 1 where c = 15 ![\color{red}{ok}](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7Bok%7D) |

1.根据上面案例8改造，将delete增加limit操作2的操作
 2.因为知道了数据加锁值加2条，故在加锁（5，10]之后发现已经有两条数据，故后面不在向后匹配加锁。所以事务B执行成功，加锁范围如下

![普通索引等值limit问题](/blogImg/普通索引等值limit问题.jpg)

# 一致性

## 定义

一致性是指事务执行结束后，**数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。**数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。

## 实现

可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。

实现一致性的措施包括：

- 保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证
- 数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等
- 应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致

