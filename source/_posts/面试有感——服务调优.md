---
title: 面试有感——服务调优
tags:
  - 服务调优
typora-root-url: ../../themes/butterfly/source
date: 2020-10-30 13:50:58
description: 网上很多人说面试造核弹，工作拧螺丝。通过这一年的工作经验，觉得其实并不是这样
cover: /blogImg/java性能优化.jpg
categories: 工作感悟
---

网上很多人说面试造核弹，工作拧螺丝，工作之前我以为他们说的是对的，工作了这一年以后，发现面试问的问题绝大部分都是基础知识，或者说是面试的岗位所需要的基础知识，很多都是工作中会实际遇到的问题。（当然除了个别奇葩面试官，会有一些劝退问题）如果自己开始不知道，完全不清楚，工作中会出大问题，面试官们也基本都是同事，他们也不想招一个进来不知道这些知识或者来了要用工作来进行学习的人。毕竟出问题可能他们也要背锅。

自己这一年工作中就遇到了一些问题，这些问题要想解决就必须要有一定的能力和习惯。自己借这篇文章写一下某些问题面试官为什么会问，有的问题可能在现在的公司和业务不会遇到，但是要想去接触更大更复杂的系统，其实这些都是基本功。虽然都是根据java服务写的，但是大同小异。

# 服务调优

Java应用性能优化是一个老生常谈的主题，典型的性能问题如页面响应慢，接口超时，服务器负载高，并发数低，数据库复制死锁等。尤其是在“大规模快猛”的互联网开发模式大行其道的Java应用程序性能的指向点非常多，磁盘，内存，网络I / O等系统因素，Java应用程序代码，JVM GC ，笔者根据个人经验，将Java性能优化分为4个层级：应用层，数据库层，框架层，JVM层。

![java性能优化](/blogImg/java性能优化.jpg)

每应用程序需要理解代码逻辑，通过Java线程栈定位有问题代码行等；数据库层次需要分析SQL，定位死锁等；框架层需要懂源代码，理解框架机制；JVM层需要对GC的类型和工作机制有深入了解，对各种JVM参数作用了然于胸。

围绕Java性能优化，有两种最基本的分析方法：现场分析法和事后分析法。现场分析法通过保留现场，再采用诊断工具分析定位。事后分析法需要通过多收集现场数据，然后立即恢复服务，同时针对收集的现场数据进行事后分析和复现。

# 性能诊断工具

性能诊断一种是针对已经确定有性能问题的系统和代码进行诊断，还有一种是对预上线系统提前性能测试，确定性能是否符合上线要求。此处主要针对前者，多数可以使用各种性能压针对Java应用程序，性能诊断工具主要分为两层：OS外观和Java应用程序（包括应用程序诊断和GC诊断）。

## 操作系统诊断

OS的诊断主要关注的是CPU，内存，I / O三个方面。

### CPU诊断工具

对于CPU主要关注平均负载（平均负载），CPU使用率，多个切换次数（上下文切换）。

通过top命令可以查看系统平均负载和CPU使用率，图为通过top命令查看某系统的状态。一般公司应该有相关监控，可能不需要实际登录服务器查看。

![top命令结果](/blogImg/top命令结果.jpg)

 load average有三个数字，分别表示过去1分钟，5分钟，15分钟机器的负载。遵循经验，若数值小于0.7 * CPU个数，则系统工作正常；若超过这个值，说明系统出现了负载问题，并且存在进一步升升达到CPU核数的四五倍，则系统的负载就明显偏高。高趋势，需要定位具体原因了。

通过vmstat命令可以查看CPU的切换次数，如图所示

![vmstat命令结果](/blogImg/vmstat命令结果.jpg)

其中：

- **r** 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。
- **b** 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。
- **swpd** 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。
- **free**  空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。
- **buff**  Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M
- **cache** cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)
- **si** 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。
- **so** 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。
- **bi** 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒
- **bo** 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。
- **in** 每秒CPU的中断次数，包括时间中断
- **cs** 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。
- **us** 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。
- **sy** 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。
- **id** 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。
- **wt** 等待IO CPU时间。

两者切换次数发生的场景主要有以下几种：1）时间片用完，CPU正常调度下一个任务；2）被其他优先级更高的任务抢占；3）执行任务碰到I / O一段，挂起步当前任务，切换到下一个任务；4）用户代码主动挂起当前任务让出CPU；5）多任务抢占资源，由于没有抢到被挂起；6）硬件中断。但在一个访问频度高，对多个对象连续加锁的代码块中就可能出现大量的切换，成为系统变量。

### 输入输出

I / O包括磁盘I / O和网络I / O，一般情况下磁盘更容易出现I / O中断。通过iostat可以查看磁盘的读写情况，通过CPU的I / O等待可以裁剪磁盘I / O如果磁盘I / O一直处于很高的状态，则说明磁盘太慢或故障，成为了性能瓶颈，需要进行应用优化或磁盘更换。

除了常用的top，ps，vmstat，iostat等命令，还有其他Linux工具可以诊断系统问题，例如mpstat，tcpdump，netstat，pidstat，sar等。Brendan总结列出了Linux不同设备类型的性能诊断工具，如图所示，可以参考。后面可能会写一篇这些命令的使用以及返回结果的总结，里面好多我还没听过。。

![Linux性能观察工具](/blogImg/Linux性能观察工具.png)

## Java诊断工具

### 应用代码诊断

通过一些应用程序监控警报，如果确定有问题的功能和代码，直接通过代码就可以定位；或者通过top + jstack，发现有问题的线程栈对于更复杂，逻辑更多的代码段，通过Stopwatch打印性能日志往往也可以定位大多数应用代码性能问题。

常用的Java应用诊断包括线程，变量，GC等方面的诊断。

#### jstack

jstack命令通常配合top使用，通过top -H -p pid定位Java进程和线程，或者ps -ef | grep java。再利用jstack -l pid转换线程栈。由于线程栈是瞬态的，因此需要多次dump，一般3次dump，一般每次隔5s就行。将top定位的Java线程pid转成16二进制，得到Java线程栈中的nid，可以找到对应的问题线程栈。

#### **JProfiler**

JProfiler可对CPU，堆，内存进行分析，功能强大，如图7所示。同时结合压测工具，可以对代码耗时采样统计。

### GC诊断

Java GC解决了程序员管理内存的风险，但GC引起了应用暂停且另一个需要解决的问题。JDK提供了一系列工具来定位GC问题，比较常用的有jstat，jmap，还有第三方工具MAT等。

#### jstat

jstat命令可打印GC详细信息，年轻GC和完整GC次数，堆信息等。其命令格式为

```shell
jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]

jstat -options

-class 显示ClassLoad的相关信息；
-compiler 显示JIT编译的相关信息；
-gc 显示和gc相关的堆信息；
-gccapacity 　　 显示各个代的容量以及使用情况；
-gcmetacapacity 显示metaspace的大小
-gcnew 显示新生代信息；
-gcnewcapacity 显示新生代大小和使用情况；
-gcold 显示老年代和永久代的信息；
-gcoldcapacity 显示老年代的大小；
-gcutil　　 显示垃圾收集信息；
-gccause 显示垃圾回收的相关信息（通-gcutil）,同时显示最后一次或当前正在发生的垃圾回收的诱因；
-printcompilation 输出JIT编译的方法信息
```

![jstat命令结果](/blogImg/jstat命令结果.jpg)

#### jmap

jmap打印Java进程堆信息jmap –heap pid。通过jmap –dump：file = xxx pid可转储堆到文件，然后通过其他工具进一步分析其堆使用情况

#### MAT

MAT是Java堆的分析利器，提供了直观的诊断报告，内置的OQL允许对堆进行类SQL查询，功能强大，传出的引用和传入的引用可以对对象引用追根溯源。

对于Java应用，通过top + jstack + jmap + MAT可以定位大多数应用和内存问题，可谓必备工具。有时，Java应用诊断需要参考OS相关信息，可使用一些更全面的诊断工具，例如Zabbix（集成了OS和JVM监控）等。在分布式环境中，分布式跟踪系统等基础设施也对应用性能诊断提供了有力支持。

# 其他调优

对于数据库层，其他关于各种数据库的文章有分别的介绍，这里就不具体写了。框架层的问题就是要熟悉各种框架源码，有源码阅读的能力，这个在我这一年的工作中经常遇到，因为框架版本的升级导致了一些问题，有时候要去对比两个版本源码的差别，才能找到原因，属实头秃。比如最近遇到的，feign的版本升级，在新版中对response的toString方法进行了重写，重写中转化字符串最后对所有流进行了关闭；之前一个项目在对response解析使用前进行了log日志记录，但是因为改版后对流进行了关闭，导致日志记录后解析response出现了报错。。也是找了一天原因对比源码后才发现这个改动。

# 总结

性能调优同样一致2-8原则，80％的性能问题是由20％的代码产生的，因此优化关键代码事半功倍。同时，对性能的优化要做到按需优化，过度优化可能发布更多问题。对于Java性能优化，既要了解系统架构，应用程序，同样需要关注JVM层甚至操作系统集成。总结起来可以从以下几点进行考虑：

1）基础性能的调优

这里的基础性能指的是硬件层级或操作系统层级的升级优化，某些网络调优，操作系统版本升级，硬件设备优化等。诸如F5的使用和SDD硬盘的发布，包括新版本Linux在NIO方面的升级，都可以极大的促进应用的性能提升；

2）数据库性能优化

包括常见的事务分解，索引调优，SQL优化，NoSQL的更新，最终解决一致性等做法的发布，包括针对具体场景发布的NoSQL数据库，都可以大大缓解传统数据库在高并发下的不足；

3）应用架构优化

以前的一些新的计算或者存储框架，利用新特性解决方案并对其进行了性能评估等；或者在分布式策略中，在计算和存储进行水平化，包括提前计算准备等，利用典型的空间转换时间的做法等；都可以在一定程度上降低系统负载；

4）业务预算的优化

技术并非提升系统性能的唯一手段，在很多出现性能问题的场景中，实际上可以看到很大一部分都是因为特殊的业务场景引起的，如果能在业务上进行规避或调整，实际上往往是最有效的。