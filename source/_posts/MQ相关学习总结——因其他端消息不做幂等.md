---
title: MQ相关学习总结——因其他端消息不做幂等
tags:
  - 消息队列
  - RockerMQ
date: 2020-09-17 14:15:35
description: 消息重复导致消费者系统报错，还把锅全甩给生产者？
cover: /blogImg/保证消息顺序的正确姿势.jpg
categories: 消息队列
typora-root-url: ../../themes/butterfly/source
---

# 问题产生

每个月老师结算的时候业务同学都会通过系统将老师工资单发送给财务打款，但是有一次业务忘记自己推送过，又点了一次，导致财务侧消息重复，产生大量报错，让我们背锅。算是认了，修改后每个账单只允许推一次，过了一段时间后，他们又发现几条重复，又找了过来，确认生产者只发了一次后，开始研究为什么他们收到了不止一次。

确认肯定不是我们这边的问题后，感觉问题只可能出在消息中间件上，因为公司的消息中间件是基于RocketMQ开发的，就开始了解了相关知识，下面进行一下相关总结

# 消息队列

## 实用场景与作用

`非实时性`：当不需要立即获得结果，但是并发量又需要进行控制的时候，差不多就是需要使用消息队列的时候。主要解决了应用耦合、异步处理、流量削锋等问题。

`应用耦合`：多应用间通过消息队列对同一消息进行处理，避免调用接口失败导致整个过程失败；（如：订单->库存）

`异步处理`：多应用对消息队列中同一消息进行处理，应用间并发处理消息，相比串行处理，减少处理时间；(点对多场景，广播场景(注册发短信，发邮件)等等)

`限流削峰`：应用于秒杀或抢购活动中，避免流量过大导致应用系统挂掉的情况；(根据服务承受度设置队列大小，超过了就返回活动结束了，咱们经常各大商城秒杀，心里还没有点B数吗)减少压力,避免服务挂掉。

`消息驱动的系统`：系统分为消息队列、消息生产者、消息消费者，生产者负责产生消息，消费者(可能有多个)负责对消息进行处理；(分工处理(各自对应相应的队列)，灵活应用(收到就处理/定时处理))

## 消息队列带来的问题

- **系统可用性降低**： 系统可用性在某种程度上降低，为什么这样说呢？在加入MQ之前，你不用考虑消息丢失或者说MQ挂掉等等的情况，但是，引入MQ之后你就需要去考虑了
- **系统复杂性提高**： 加入MQ之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题
- **一致性问题**： 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了

## 两种模式

1. `点对点`：每个消息只有一个消费者（Consumer），不可重复消费(一旦被消费，消息就不再在消息队列中)
2. `发布/订阅`：微信公众号(Topic)，大伙(订阅者)订阅关注之后，微信公众号运营平台(发布者)发布信息后，大伙微信就都收到信息了，这里其实还分pull/push的。一个是主动推送，一个是被动拉取
	 **`基于发布/订阅模式做扩展就是横向扩展，多个队列及消费分组订阅(提高消费能力)`**

- `pull`：主动权在于消费方，优点是按需消费(吃自助餐，能吃多少拿多少)，而且服务端队列堆积的消息处理也相对简单(不用记录状态啊，状态都消费端)；缺点就是消息延迟(不知道啥时候去拉取更新)，这时候有小伙伴会问，那为啥不叫服务端通知一下呢(有句话叫不在其位不谋其政，服务端通知必然要记录通知状态和增加之间的通信带宽；当然也可以根据实际情况来选择和push组合起来用(男女搭配干活不累嘛)来提高消息的实时性)
- `push`：主动权就在服务方了，优点是实时性高，服务端可以统一管理来进行负载，不过也容易导致慢消费(就得考虑消费方受不受得了，毕竟你说你了解，但也只有对方才清楚你有多了解)；缺点就是发送消息的状态是集中式管理，压力大啊(要分发消息还要记录状态还要做备份，又当爹来又当妈)
	 **`对于顺序消息，这种场景有限且成本太高的方式就得慎重考虑了，对那种全局有序但允许出现小误差的场景(日志推送)，pull模式就非常适合了(所以说kafka为啥常用于日志处理、大数据等方面)`**

## 4大消息队列对比

| 特性                    |                        ActiveMq                         |                        RabbitMq                        |                           RocketMQ                           |                            Kafka                             | ZeroMQ                                                       |
| ----------------------- | :-----------------------------------------------------: | :----------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | ------------------------------------------------------------ |
| 成熟度                  |                          成熟                           |                          成熟                          |                           比较成熟                           |                        成熟的日志领域                        |                                                              |
| 时效性                  |                                                         |                         微秒级                         |                            毫秒级                            |                            毫秒级                            |                                                              |
| 开发语言                |                          Java                           |                         Erlang                         |                             Java                             |                            Scala                             | C语言                                                        |
| 支持的协议              |            OpenWire、STOMP、REST、XMPP、AMQP            |                          AMQP                          |                       自己定义的一套…                        |                  自己定义的一套…（基于TCP）                  | TCP、UDP                                                     |
| 社区活跃度              |                           低                            |                           高                           |                              高                              |                              高                              | 低                                                           |
| 消息存储与堆积          |           内存、磁盘、数据库。支持少量堆积。            |               内存、磁盘。支持少量堆积。               |                     磁盘。支持大量堆积。                     |              内存、磁盘、数据库。支持大量堆积。              | 消息发送端的内存或者磁盘中。不支持持久化。                   |
| 消息事务                |                          支持                           |                          支持                          |                             支持                             |                             支持                             | 不支持                                                       |
| 负载均衡                |                          支持                           |                        支持不好                        |                             支持                             |                             支持                             | 不支持                                                       |
| 单机吞吐量              |      万级，吞吐量比RocketMQ和Kafka要低了一个数量级      |     万级，吞吐量比RocketMQ和Kafka要低了一个数量级      |          10万级，RocketMQ也是可以支撑高吞吐的一种MQ          | 10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |                                                              |
| 集群方式                | 支持简单集群模式，比如'主-备'，对高级集群模式支持不好。 |   支持简单集群，'复制'模式，对高级集群模式支持不好。   | 常用 多对'Master-Slave' 模式，开源版本需手动切换Slave变成Master。 | 天然的‘Leader-Slave’无状态集群，每台服务器既是Master也是Slave。 | 去中心化，不支持集群。                                       |
| topic数量对吞吐量的影响 |                                                         |                                                        | topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会大幅度下降所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 |                                                              |
| 可用性                  |              高，基于主从架构实现高可用性               |              高，基于主从架构实现高可用性              |                      非常高，分布式架构                      | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 | 高                                                           |
| 消息可靠性              |                  有较低的概率丢失数据                   |                                                        |               经过参数优化配置，可以做到0丢失                |             经过参数优化配置，消息可以做到0丢失              |                                                              |
| 消息重复                |                    支持at least once                    |            支持at least once、at most once             |                      支持at least once                       |               支持at least once、at most once                | 只有重传机制，但是没有持久化，消息丢了重传也没有用。既不是at least once、也不是at most once、更不是exactly only once |
| 功能支持                |                  MQ领域的功能极其完备                   | 基于erlang开发，所以并发能力很强，性能极其好，延时很低 |            MQ功能较为完善，还是分布式的，扩展性好            | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |                                                              |

具体的几个mq的实现方式还需要在学习学习再总结，java的源码能看看，C的源码也能努力看看，其他的可能暂时比较费劲了。。

下面总结几个涉及到这次问题的几个知识点

**一、顺序消息**

消息有序指的是可以按照消息的发送顺序来消费。例如：一笔订单产生了 3 条消息，分别是订单创建、订单付款、订单完成。消费时，要按照顺序依次消费才有意义。与此同时多笔订单之间又是可以并行消费的。首先来看如下示例：

假如生产者产生了2条消息：M1、M2，要保证这两条消息的顺序，应该怎样做？你脑中想到的可能是这样：

![你可能会采用这种方式保证消息顺序](/blogImg/你可能会采用这种方式保证消息顺序  .jpg)

假定M1发送到S1，M2发送到S2，如果要保证M1先于M2被消费，那么需要M1到达消费端被消费后，通知S2，然后S2再将M2发送到消费端。

这个模型存在的问题是，如果M1和M2分别发送到两台Server上，就不能保证M1先达到MQ集群，也不能保证M1被先消费。换个角度看，如果M2先于M1达到MQ集群，甚至M2被消费后，M1才达到消费端，这时消息也就乱序了，说明以上模型是不能保证消息的顺序的。**如何才能在MQ集群保证消息的顺序？一种简单的方式就是将M1、M2发送到同一个Server上：**

![保证消息顺序，你改进后的方法](/blogImg/保证消息顺序，你改进后的方法.jpg)

这样可以保证M1先于M2到达MQServer（生产者等待M1发送成功后再发送M2），根据先达到先被消费的原则，M1会先于M2被消费，这样就保证了消息的顺序。

这个模型也仅仅是理论上可以保证消息的顺序，在实际场景中可能会遇到下面的问题：

![网络延迟问题](/blogImg/网络延迟问题.jpg)

网络延迟问题

只要将消息从一台服务器发往另一台服务器，就会存在网络延迟问题。如上图所示，如果发送M1耗时大于发送M2的耗时，那么M2就仍将被先消费，仍然不能保证消息的顺序。即使M1和M2同时到达消费端，由于不清楚消费端1和消费端2的负载情况，仍然有可能出现M2先于M1被消费的情况。

那如何解决这个问题？将M1和M2发往同一个消费者，且发送M1后，需要消费端响应成功后才能发送M2。

聪明的你可能已经想到另外的问题：如果M1被发送到消费端后，消费端1没有响应，那是继续发送M2呢，还是重新发送M1？一般为了保证消息一定被消费，肯定会选择重发M1到另外一个消费端2，就如下图所示。

![保证消息顺序的正确姿势](/blogImg/保证消息顺序的正确姿势.jpg)

 这样的模型就严格保证消息的顺序，细心的你仍然会发现问题，消费端1没有响应Server时有两种情况，一种是M1确实没有到达(数据在网络传送中丢失)，另外一种消费端已经消费M1且已经发送响应消息，只是MQ Server端没有收到。如果是第二种情况，重发M1，就会造成M1被重复消费。也就引入了我们要说的第二个问题，消息重复问题，这个后文会详细讲解。

回过头来看消息顺序问题，严格的顺序消息非常容易理解，也可以通过文中所描述的方式来简单处理。总结起来，要实现严格的顺序消息，简单且可行的办法就是：

**保证生产者 - MQServer - 消费者是一对一对一的关系** 

这样的设计虽然简单易行，但也会存在一些很严重的问题，比如：

1. 并行度就会成为消息系统的瓶颈（吞吐量不够）
2. 更多的异常处理，比如：只要消费端出现问题，就会导致整个处理流程阻塞，我们不得不花费更多的精力来解决阻塞的问题。

但我们的最终目标是要集群的高容错性和高吞吐量。这似乎是一对不可调和的矛盾，那么阿里是如何解决的？

**世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！——沈询**

有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。从这个角度来看消息的顺序问题，我们可以得出两个结论：

1. 不关注乱序的应用实际大量存在
2. 队列无序并不意味着消息无序

所以从业务层面来保证消息的顺序而不仅仅是依赖于消息系统，是不是我们应该寻求的一种更合理的方式？

**二、消息重复**

上面在解决消息顺序问题时，引入了一个新的问题，就是消息重复。那么RocketMQ是怎样解决消息重复的问题呢？还是“恰好”不解决。

造成消息重复的根本原因是：网络不可达。只要通过网络交换数据，就无法避免这个问题。所以解决这个问题的办法就是绕过这个问题。那么问题就变成了：如果消费端收到两条一样的消息，应该怎样处理？

1. 消费端处理消息的业务逻辑保持幂等性
2. 保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现

第1条很好理解，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。第2条原理就是利用一张日志表来记录已经处理成功的消息的ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息。

第1条解决方案，很明显应该在消费端实现，不属于消息系统要实现的功能。第2条可以消息系统实现，也可以业务端实现。正常情况下出现重复消息的概率其实很小，如果由消息系统来实现的话，肯定会对消息系统的吞吐量和高可用有影响，所以最好还是由业务端自己处理消息重复的问题，这也是RocketMQ不解决消息重复的问题的原因。

**RocketMQ不保证消息不重复，如果你的业务需要保证严格的不重复消息，需要你自己在业务端去重。**